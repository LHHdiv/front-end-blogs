export const data = JSON.parse("{\"key\":\"v-c3ff4b80\",\"path\":\"/vues/v3/compositionAPI.html\",\"title\":\"组合式API\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"组合式API\",\"order\":1,\"index\":true,\"icon\":\"laptop-code\",\"category\":[\"Vue\"],\"description\":\"什么是 Composition API(组合式) 选项式 API 基于对象: 组件的各个方面都是在一个对象中进行声明,如 data、methods、computed、watch 等 逻辑分散: 相关的逻辑可能在不同的选项中分散，难以迅速理解组件的整体逻辑 语法较早：这是 Vue.js 最早期的编写组件的方式，现在仍然支持 组合式 API 基于函数：组件的逻辑被封装在函数中，称为 \\\"Composition Function\\\" 逻辑集中：相关逻辑可以在同一个 Composition Function 中进行组合，提高了代码的可读性和维护性 更灵活：可以更方便地共享逻辑、重用代码，以及在不同组件之间更容易地组织和调整代码\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"http://www.mashimaro.top/vues/v3/compositionAPI.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"博客\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"组合式API\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"什么是 Composition API(组合式) 选项式 API 基于对象: 组件的各个方面都是在一个对象中进行声明,如 data、methods、computed、watch 等 逻辑分散: 相关的逻辑可能在不同的选项中分散，难以迅速理解组件的整体逻辑 语法较早：这是 Vue.js 最早期的编写组件的方式，现在仍然支持 组合式 API 基于函数：组件的逻辑被封装在函数中，称为 \\\"Composition Function\\\" 逻辑集中：相关逻辑可以在同一个 Composition Function 中进行组合，提高了代码的可读性和维护性 更灵活：可以更方便地共享逻辑、重用代码，以及在不同组件之间更容易地组织和调整代码\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"LJK\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"组合式API\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"LJK\\\",\\\"url\\\":\\\"http://www.mashimaro.top/\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"什么是 Composition API(组合式)\",\"slug\":\"什么是-composition-api-组合式\",\"link\":\"#什么是-composition-api-组合式\",\"children\":[]},{\"level\":2,\"title\":\"选项式 vs 组合式(状态与事件)\",\"slug\":\"选项式-vs-组合式-状态与事件\",\"link\":\"#选项式-vs-组合式-状态与事件\",\"children\":[]},{\"level\":2,\"title\":\"常用 Composition API\",\"slug\":\"常用-composition-api\",\"link\":\"#常用-composition-api\",\"children\":[]},{\"level\":2,\"title\":\"ref 和 reactive 和 shallowRef 的区别\",\"slug\":\"ref-和-reactive-和-shallowref-的区别\",\"link\":\"#ref-和-reactive-和-shallowref-的区别\",\"children\":[]},{\"level\":2,\"title\":\"setup 详解\",\"slug\":\"setup-详解\",\"link\":\"#setup-详解\",\"children\":[]},{\"level\":2,\"title\":\"watchEffect 和 watch 的区别\",\"slug\":\"watcheffect-和-watch-的区别\",\"link\":\"#watcheffect-和-watch-的区别\",\"children\":[]}],\"readingTime\":{\"minutes\":1.98,\"words\":594},\"filePathRelative\":\"vues/v3/compositionAPI.md\",\"excerpt\":\"<h2> 什么是 Composition API(组合式)</h2>\\n<h4> 选项式 API</h4>\\n<ul>\\n<li>基于对象: 组件的各个方面都是在一个对象中进行声明,如 data、methods、computed、watch 等</li>\\n<li>逻辑分散: 相关的逻辑可能在不同的选项中分散，难以迅速理解组件的整体逻辑</li>\\n<li>语法较早：这是 Vue.js 最早期的编写组件的方式，现在仍然支持</li>\\n</ul>\\n<h4> 组合式 API</h4>\\n<ul>\\n<li>基于函数：组件的逻辑被封装在函数中，称为 \\\"Composition Function\\\"</li>\\n<li>逻辑集中：相关逻辑可以在同一个 Composition Function 中进行组合，提高了代码的可读性和维护性</li>\\n<li>更灵活：可以更方便地共享逻辑、重用代码，以及在不同组件之间更容易地组织和调整代码</li>\\n</ul>\",\"autoDesc\":true}")

if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
